---
import Layout from '../components/Layout.astro';
import WishlistForm from '../components/WishlistForms.tsx';
import { getCollection } from 'astro:content';
import { getBasePath } from '../lib/paths';
import { getAllPractitioners } from '../lib/db';
import { getOAuthProvider } from '../lib/oauth/registry.js';
import { verifySession } from '../lib/github-oauth';
import type { OAuthProviderName } from '../lib/oauth/types';

const services = await getCollection('services');

// Fetch practitioners from database with error handling
let practitioners = [];
try {
  practitioners = await getApprovedPractitioners();
} catch (error) {
  console.error('[create-wishlist] Error fetching practitioners:', error);
}

const practitionerCounts = services.reduce((acc, s) => {
  const slug = s.slug;
  const count = practitioners.filter(p => Array.isArray(p.services) && p.services.includes(slug)).length;
  acc[slug] = count;
  return acc;
}, {} as Record<string, number>);

const servicesData = services.map(service => {
  const slug = service.slug;
  const declaredAvailable = service.data.available ?? true;
  const count = practitionerCounts[slug] ?? 0;
  return {
    id: slug,
    title: service.data.title,
    description: service.data.description,
    slug,
    available: declaredAvailable,
    practitionerCount: count,
    unavailableReason: service.data.unavailable_reason ?? undefined,
  };
});

const practitionersData = practitioners.map(p => ({
  slug: p.github_username,
  name: p.name,
  github: p.github_username || '',
}));

console.log(`[create-wishlist] Passing ${practitionersData.length} practitioners to WishlistForm component`);

const user = Astro.locals.user;
const basePath = getBasePath();

// Handle authentication redirect server-side
if (!user) {
  const currentPath = Astro.url.pathname;
  const searchParams = Astro.url.search;
  
  // Strip the base path if it exists to get the relative path
  let relativePath = currentPath.startsWith(basePath.slice(0, -1)) 
    ? currentPath.slice(basePath.slice(0, -1).length)
    : currentPath;
  
  // Ensure relativePath starts with /
  if (relativePath && !relativePath.startsWith('/')) {
    relativePath = '/' + relativePath;
  }
  if (!relativePath) {
    relativePath = '/';
  }
  
  // Redirect to login page with return URL
  const fullReturnPath = relativePath + searchParams;
  const returnTo = encodeURIComponent(fullReturnPath);
  return Astro.redirect(`${basePath}login?returnTo=${returnTo}`);
}

// Fetch user's repositories server-side using the correct OAuth provider
let userRepositories = [];
try {
  // Get the session data first to check if we have cached repositories
  const sessionCookie = Astro.cookies.get('oss_session')?.value || Astro.cookies.get('github_session')?.value;
  if (sessionCookie) {
    const sessionSecret = import.meta.env.OAUTH_STATE_SECRET || process.env.OAUTH_STATE_SECRET;
    if (!sessionSecret) {
      throw new Error('Session secret not configured');
    }
    
    const sessionData = verifySession(sessionCookie, sessionSecret);
    
    // First, try to use cached repositories from session (avoids rate limits)
    if (sessionData?.repositories && sessionData.repositories.length > 0) {
      userRepositories = sessionData.repositories;
    } else {
      // Fall back to fetching repositories if not in session (e.g., old sessions)
      const providerName: OAuthProviderName = (user.provider as OAuthProviderName) || 'github';
      const provider = getOAuthProvider(providerName);
      
      if (provider && sessionData?.accessToken) {
        try {
          const fullRepos = await provider.fetchUserRepositories(sessionData.accessToken);
          // Convert to minimal format matching session storage
          userRepositories = fullRepos.map(repo => ({
            id: repo.id,
            name: repo.name,
            full_name: repo.full_name,
            html_url: repo.html_url,
            description: repo.description,
            private: repo.private,
          }));
        } catch (fetchError) {
          console.error('[create-wishlist] Error fetching repositories from provider:', fetchError);
        }
      } else {
        console.error(`[create-wishlist] OAuth provider not available or no access token: ${providerName}`);
      }
    }
  }
} catch (error) {
  console.error('[create-wishlist] Error loading repositories:', error);
}
---

<Layout title="Create a Wishlist - OSS Wishlist" description="Create a new wishlist for your open source project.">
  <section class="py-12 bg-gray-50">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="max-w-4xl mx-auto">
        <h1 class="text-5xl font-bold text-gray-900 mb-4">
          <span class="text-accent">Create</span> a New Wishlist
        </h1>
        <p class="text-gray-600 text-base mb-8">
          Choose from the provided list of repositories associated with your account or provide a different project URL. You may only create one wishlist per project.
          <br />
          <strong>Note:</strong> New wishes remain in a <em>pending</em> state until verified (to prevent spam). Once verified, they'll appear publicly and be eligible for fulfillment.
        </p>
        <WishlistForm client:load services={servicesData} practitioners={practitionersData} user={user} initialRepositories={userRepositories} />
      </div>
    </div>
  </section>

  <script define:vars={{ basePath }}>
    // Listen for successful wishlist creation
    window.addEventListener('wishlist-created', () => {
      setTimeout(() => {
        window.location.href = basePath + 'maintainers';
      }, 2000);
    });
  </script>
</Layout>
